<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 10px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

circle.selected {
  stroke-width: 1px;
  stroke: #555;
}

path {
      fill: none;
      /*fill-opacity: .065;*/
      stroke-width: 1px;
      stroke: #666;
    }


.svg {
  display: inline-block;
  vertical-align: top;
}

.divListGens {
  display: inline-block;
  vertical-align: top;
  margin-left: 1em;
}


.img_sub {
    position: absolute;
    z-index: -1;
}

.img_sup {
    position: absolute;
    z-index: -1;
}

.brush .extent {
  stroke: #fff;
  fill-opacity: .25;
  shape-rendering: crispEdges;
}


#slide {
  font-size: 1.5em;
}

</style>


    <script src="http://d3js.org/d3.v3.min.js"></script>



<body>


SUBLEVEL PERSISTENCE
<div id="imgContainer_sub"></div>

<div id="divImg_sub" class="svg"></div>

<div id="applicationArea_sub" class="svg">
  <!-- The two persistence diagrams are created here -->
</div>

<br />

SUPERLEVEL PERSISTENCE
<div id="imgContainer_sup"></div>

<div id="divImg_sup" class="svg"></div>

<div id="applicationArea_sup" class="svg">
  <!-- The two persistence diagrams are created here -->
</div>

<p></p>
<div id="slide" class="svg" ></div>
<p></p>
<div id="listGens" class="svg"></div>

<script>


// SET PAGE PARAMETERS

var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 421 - margin.left - margin.right,
    height = 421 - margin.top - margin.bottom,
    brushwidth = 421,
    brushheight = 421;

var sizeUnselected = 2;
var sizeSelected = 4;

var img1Dir = "g21per/bmps_cropped";
var img2Dir = "g21flow/bmps_cropped";
var dataDir_sub = "g21per/pd_sublevel";
var dataDir_sup = "g21per/pd_superlevel";

var limit1 = 1;
var limit2 = 1500;

// HELPER FUNCTIONS FOR PAGE LOADING

function padnum(n, p, c) {
    var pad_char = typeof c !== 'undefined' ? c : '0';
    var pad = new Array(1 + p).join(pad_char);
    return (pad + n).slice(-pad.length);
}

// GET/SET PARAMETERS FROM URL

function $_GET(param) {
  var vars = {};
  window.location.href.replace( location.hash, '' ).replace( 
    /[?&]+([^=&]+)=?([^&]*)?/gi, // regexp
    function( m, key, value ) { // callback
      vars[key] = value !== undefined ? value : '';
    }
  );

  if ( param ) {
    return vars[param] ? vars[param] : null;  
  }
  return vars;
}

var imgTrail = +$_GET('trail');

if (imgTrail == 0) {
  imgTrail = 10;
}

var imgStart = +$_GET('imgStart');

if (imgStart == 0) {
  alert("Please use ?imgStart=N as parameter input, where "+limit1+" <= N <= "+limit2+" - trail. Defaulting to N="+limit1+".");
  imgStart = limit1;
}
if (imgStart < limit1 || imgStart > limit2 - imgTrail) {
  alert("Exceeding range of "+limit1+" <= N <= "+limit2+" - trail. Please choose a different N. Setting N="+limit1+".");
  imgStart = limit1;
}

var imgs1 = [];
for (var i=imgStart; i <= (imgStart + imgTrail); i++) {
  imgs1.push(img1Dir + "/"+padnum(i,5)+".bmp");
}
var imgs2 = [];
for (var i=imgStart; i <= (imgStart + imgTrail); i++) {
  imgs2.push(img2Dir + "/"+padnum(i,5)+".bmp");
}

var listGens = +$_GET('listGens');

var selector = +$_GET('selector');
// 1 = sub, dim=0
// 2 = sub, dim=1
// 3 = sup, dim=0
// 4 = sup, dim=1
if (selector == 0) {
  selector = 1;
}




// SET GLOBAL DATA VARIABLES
var data_sub=[];
var data_sup=[];

var files_sub = [];
for (var i=imgStart; i <= (imgStart + imgTrail); i++) {
  files_sub.push(dataDir_sub + "/"+padnum(i,5)+"__sub_all.csv");
}

var files_sup = [];
for (var i=imgStart; i <= (imgStart + imgTrail); i++) {
  files_sup.push(dataDir_sup + "/"+padnum(i,5)+"__super_all.csv");
}


// PREPROCESSING FUNCTIONS

function loadImgs(_imgs1, _imgs2,onComplete) {
  for (var i=imgStart; i <= (imgStart + imgTrail); i++) {


      d3.select("#imgContainer_sub")
          .append('img')
            .attr('src', _imgs1[i - imgStart])
            .attr('id', 'img_sub_'+i)
            .attr('class', 'img_sub')

      d3.select("#imgContainer_sup")
          .append('img')
            .attr('src', _imgs2[i - imgStart])
            .attr('id', 'img_sup_'+i)
            .attr('class', 'img_sup')

  }

  onComplete();

}

function loadData(_files, _cb, _data, _i) {
  _data = _data || [];
  _i = _i || 0;
  d3.csv(_files[_i], function(error, dataset) {

    dataset.forEach(function(d) {
      d.birth = +d.birth;
      d.death = +d.death;
      d.time = _i+imgStart;
      d.selected = false;
    });

    _data = _data.concat(dataset);

    if(_i < _files.length - 1){
      //load next file
      loadData(_files, _cb, _data, _i+1);
    } else {
      //call the callback with the final sum
      _cb(_data);
    }
  });
}


// Color of the points for reverse search
var colorInside = d3.scale.linear()
  .domain([imgStart, (imgStart + imgTrail)])
  .range(["orange", "red"]);
var colorOutside = d3.scale.linear()
  .domain([imgStart, (imgStart + imgTrail)])
  .range(["gray", "blue"]);

function getColor(_d, _extent) {
  var b_x = parseFloat(_d.b_x);
  var b_y = parseFloat(_d.b_y);
  var d_x = parseFloat(_d.d_x);
  var d_y = parseFloat(_d.d_y);

  if ( ( _extent[0][0] <= b_x ) && ( b_x <= (_extent[1][0]) ) && ( _extent[0][1] <= b_y ) && ( b_y <= _extent[1][1] )
    || ( _extent[0][0] <= d_x ) && ( d_x <= (_extent[1][0]) ) && ( _extent[0][1] <= d_y ) && ( d_y <= _extent[1][1] ) ){
    return colorInside(_d.time);
  }
  else{
    return colorOutside(_d.time);
  }
}

function getSize(_d, _extent) {
  var b_x = parseFloat(_d.b_x);
  var b_y = parseFloat(_d.b_y);
  var d_x = parseFloat(_d.d_x);
  var d_y = parseFloat(_d.d_y);

  if ( ( _extent[0][0] <= b_x ) && ( b_x <= (_extent[1][0]) ) && ( _extent[0][1] <= b_y ) && ( b_y <= _extent[1][1] )
    || ( _extent[0][0] <= d_x ) && ( d_x <= (_extent[1][0]) ) && ( _extent[0][1] <= d_y ) && ( d_y <= _extent[1][1] ) ){
    return sizeSelected;
  }
  else{
    return sizeUnselected;
  }
}


// ACTUAL PAGE COMMANDS

loadImgs(imgs1, imgs2,function() {

  initializeImageArea();

  var svgImg_sub = d3.select("#divImg_sub")
      .append("svg")
        .attr("width", width + margin.left + margin.right + 20)
        .attr("height", height + margin.top + margin.bottom + 20)
        .attr("id","svgImg_sub")

  var svgImg_sup = d3.select("#divImg_sup").append("svg")
      .attr("width", width + margin.left + margin.right + 20)
      .attr("height", height + margin.top + margin.bottom + 20)
      .attr("id","svgImg_sup")



  loadData(files_sub, function(data_sub){

    loadData(files_sup, function(data_sup){

      // Initialize reverse selector brush (nothing selected)
      var brush = d3.svg.brush()
          .x(d3.scale.identity().domain([0, brushwidth]))
          .y(d3.scale.identity().domain([0, brushheight]))
          .on("brushend", brushed);

      svgImg_sub.append("g")
        .attr("class", "brush")
        .call(brush);


      // Generate the four scatter plots.
      scatterPlot(data_sub,1,brush);
      scatterPlot(data_sub,2,brush);
      scatterPlot(data_sup,3,brush);
      scatterPlot(data_sup,4,brush);

      // Recolor persistence points based on new brush region
      function brushed() {

        var extent = brush.extent();
        for (var i=1; i <= 4; i++) {
          alldots = d3.select("#svg_"+i).selectAll("circle")
            .style("fill",null) // clear all of the fills
            .attr("r",sizeUnselected) // clear all of the fills
          alldots.each(function(d,j) {
            d3.select(this).style("fill", function(d) { return getColor(d, extent); });
            d3.select(this).attr("r", function(d) { return getSize(d, extent); });
          });
        }

      }

    });

  });


  // ACTIVE PAGE FUNCTIONS

  function scatterPlot( _data, _graphCounter, _brush ){

    var extent = _brush.extent();

    areaCreator(_graphCounter);

    var x = d3.scale.linear()
        .range([0, width]);

    var y = d3.scale.linear()
        .range([height, 0]);

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom");

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left");

    var svg = d3.select("#graphArea"+_graphCounter).append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("class","svg")
        .attr("id","svg_"+_graphCounter)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Transforms placement of center of points onto plane (vs absolute coordinates)
    x.domain(d3.extent(_data, function(d) { return d.birth; })).nice();
    y.domain(d3.extent(_data, function(d) { return d.death; })).nice();

    // Style and build the scatter plot
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis)
      .append("text")
        .attr("class", "label")
        .attr("x", width)
        .attr("y", -6)
        .style("text-anchor", "end")
        .text("birth");
    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis)
      .append("text")
        .attr("class", "label")
        .attr("transform", "rotate(-90)")
        .attr("y", 6)
        .attr("dy", ".71em")
        .style("text-anchor", "end")
        .text("death")
    // Plot the persistence plane
    svg.selectAll(".dot")
        // Filter by dimension
        .data(_data.filter(function(d) {return d.dim == ((_graphCounter-1) % 2)}))
      .enter().append("circle")
        .attr("id",function(d,i) {return "dot_" + i;}) // added
        .attr("class", "dot_"+_graphCounter)
        // Center of points
        .attr("cx", function(d) { return x(d.birth); })
        .attr("cy", function(d) { return y(d.death); })
        // Color and size according to time or reverse selection color
        .style("fill", function(d) { return getColor(d, extent); })
        .attr("r", function(d) { return getSize(d, extent); });

    // Title of plot
    svg.append("text")
        .attr("class", "title")
        .attr("x", width/2)
        .attr("y", 0 - (margin.top / 2))
        .attr("text-anchor", "middle")
        .text("Dim " + ((_graphCounter-1) % 2));


    if ( selector == _graphCounter ) {
      var coords = [],
          selecteddata = [],

          line = d3.svg.line(),

          dragStart = function() {
            coords = [];
            g.selectAll("path").remove();

          },

          drawPath = function(terminator) {
            g.append("path").attr({
              d: line(coords)
            });
            if (terminator) {
              g.select("#terminator").remove();
              g.append("path").attr({
                id: "terminator",
                d: line([coords[0], coords[coords.length-1]])
              });
            }
          },

          dragMove = function() {
            dot.classed("selected", false);
            coords.push(d3.mouse(this));
            dot.each(function(d, i) {
              d.selected = false;
              var p_x = parseFloat(d3.select(this).attr("cx"));
              var p_y = parseFloat(d3.select(this).attr("cy"));
              point = [p_x + margin.left, p_y + margin.top];
              if (pointInPolygon(point, coords)) {
                d3.select(this).classed("selected", true)
                d.selected = true;
              }
            });
            drawPath();
          },

          dragEnd = function() {
            drawPath(true);

            runAnimation(dot);
            if (listGens) {
              listGenerators(dot);
            }
          }

          drag = d3.behavior.drag()
                    .on("dragstart", dragStart)
                    .on("drag", dragMove)
                    .on("dragend", dragEnd),

          // from https://github.com/substack/point-in-polygon
          pointInPolygon = function (point, vs) {
            // ray-casting algorithm based on
            // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
            var xi, xj, i, intersect,
                x = point[0],
                y = point[1],
                inside = false;
            for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
              xi = vs[i][0],
              yi = vs[i][1],
              xj = vs[j][0],
              yj = vs[j][1],
              intersect = ((yi > y) != (yj > y))
                  && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
              if (intersect) inside = !inside;
            }
            return inside;
          },


          mysvg = d3.select("#svg_"+_graphCounter).call(drag),

          dot = d3.selectAll(".dot_"+_graphCounter),

          g = mysvg.append("g")
            .attr("id","pointselector"+_graphCounter);

    }

  }

  function imageUpdate( _data, _idx, _svg ){

      // Remove previous drawings
      _svg.selectAll(".dot_img")
        .remove();


      // Update new data
      _svg.selectAll(".dot")
          .data(_data.data().filter(function(d) {return d.time == _idx & d.dim == ((selector - 1)%2) & d.selected===true}))
          .enter()
        .append("circle")
          .attr("id",function(d,i) {return "dot_" + i;}) // added
          .attr("class", "dot_img")
          .attr("r", 3)
          .attr("cx", function(d) { return d.b_x; })
          .attr("cy", function(d) { return d.b_y; })
          .style("stroke","cyan")
          .style("fill", 'none');

      _svg.selectAll(".dot")
          .data(_data.data().filter(function(d) {return d.time == _idx & d.dim == ((selector - 1)%2) & d.selected===true}))
          .enter()
        .append("circle")
          .attr("id",function(d,i) {return "dot_" + i;}) // added
          .attr("class", "dot_img")
          .attr("r", 3)
          .attr("cx", function(d) { return d.d_x; })
          .attr("cy", function(d) { return d.d_y; })
          .style("stroke","cyan")
          .style("fill", "cyan");

      _svg.selectAll(".dot")
          .data(_data.data().filter(function(d) {return d.time == _idx & d.dim == ((selector - 1)%2) & d.selected===true}))
          .enter()
        .append("line")
          .attr("class", "dot_img")
          .attr("x1", function(d) { return d.b_x; })
          .attr("y1", function(d) { return d.b_y; })
          .attr("x2", function(d) { return d.d_x; })
          .attr("y2", function(d) { return d.d_y; })
          .style("stroke","cyan");


    }

    // Image area initialization
    function initializeImageArea () {
      d3.select("#img_sub_"+imgStart)
      .attr('style','');

      d3.select("#img_sup_"+imgStart)
      .attr('style','');

      var svgSlide = d3.select("#slide")
          .append("text")
            .attr("id","slideNo")
            .text("Sample point: " + imgStart);

    }

    //Area Creator
    function areaCreator (_counter){

      if ( _counter <= 2 ) {
        d3.select("#applicationArea_sub").append("div")
                  .attr({
                    class:"svg",
                    "id":"graphArea"+_counter
                  })
      } else {
        d3.select("#applicationArea_sup").append("div")
                  .attr({
                    class:"svg",
                    "id":"graphArea"+_counter
                  })
      }
    }

    function runAnimation (_data) {

      var j = imgStart;
      var playInterval = setInterval(function() {

        // Update the bitmap images
        d3.select("#img_sub_"+j)
          .attr("style","");
        if (j == imgStart) {
          for (var i = j+1; i <= imgStart + imgTrail; i++ ) {
            d3.select("#img_sub_"+(i))
              .attr("style","display: none");
          }
        } else {
          d3.select("#img_sub_"+j-1)
            .attr("style","display: none");
        }
        d3.select("#img_sup_"+j)
          .attr("style","");
        if (j == imgStart) {
          for (var i = j+1; i <= imgStart + imgTrail; i++ ) {
            d3.select("#img_sup_"+(i))
              .attr("style","display: none");
          }
        } else {
          d3.select("#img_sup_"+j-1)
            .attr("style","display: none");
        }

        // Update slide number
        d3.select("#slideNo")
          .text("Sample point: " + j);

        // Update the drawings overlaid on the iamge
        imageUpdate(_data, j, svgImg_sub);
        imageUpdate(_data, j, svgImg_sup);
        j++;
        if (j > (imgStart + imgTrail)) {
          clearInterval(playInterval);
        }
      }, 250);
    };


    function listGenerators (_data) {

      // Remove existing table
      d3.select("#listGens").selectAll("*").remove();

      // Regenerate table
      for (var i=imgStart; i <= (imgStart + imgTrail); i++) {

        // Generate the column header
        d3.select("#listGens")
          .append("div")
            .attr("id","listGens_"+i)
            .attr("class","divListGens")
            .append("div")
              .attr("id","listGensHeader")
              .text("Sample point: " +i);

        // Generate the data for the column
        d3.select("#listGens_"+i).selectAll("genDataPoint")
            .data(_data.data().filter(function(d) {return d.time===i & d.selected===true}))
            .enter()
            .append("div")
              .attr("class", "genDataPoint")
              .text(function(d) { return "( "+d.birth +" , "+d.death+" )"; });

      }

    }



});


</script>




</body>

</html>
